### **Лабораторная работа №9: Принципы поддержания качества кода**

**Тема:** Рефакторинг системы учета сотрудников на основе принципов чистого кода и SOLID.

**Цель работы:** Освоить практические навыки рефакторинга существующего кода, применения принципов SOLID, устранения "запахов кода" и улучшения архитектуры системы.

**Стек технологий:**
- **Язык программирования:** Python 3.x
- **Инструменты анализа кода:** `pylint`, `black`, `mypy`
- **Система контроля версий:** Git
- **IDE:** PyCharm / VSCode с настроенными линтерами

---

### **Задание на практическую реализацию:**

#### **Часть 1: Анализ существующего кода**

1. **Установка инструментов качества:**
   ```bash
   pip install pylint black mypy
   ```

2. **Анализ кодовой базы:**
   - Запустите статический анализ кода с помощью `pylint`
   - Проведите проверку типов с помощью `mypy`
   - Сформируйте отчет о наиболее критичных проблемах

3. **Выявление "запахов плохого кода":**
   - Составьте список основных архитектурных проблем
   - Определите нарушения принципов SOLID
   - Выявите дублирование кода и сложные методы

#### **Часть 2: Применение принципов SOLID**

**2.1. Принцип единственной ответственности (SRP):**
- Выделите из классов `Employee`, `Department` несвязанные ответственности
- Создайте отдельные классы для:
  - Сериализации/десериализации данных
  - Валидации входных параметров
  - Логирования операций
  - Расчетов зарплат

**2.2. Принцип открытости/закрытости (OCP):**
- Рефакторите систему расчета бонусов с использованием паттерна Strategy
- Создайте интерфейс `BonusStrategy` и реализации:
  ```python
  class PerformanceBonusStrategy:
      def calculate_bonus(self, employee) -> float:
          pass

  class SeniorityBonusStrategy:
      def calculate_bonus(self, employee) -> float:
          pass
  ```

**2.3. Принцип подстановки Лисков (LSP):**
- Проверьте иерархию классов сотрудников на соответствие LSP
- Убедитесь, что все подклассы могут использоваться вместо базового класса
- Исправьте нарушения контрактов методов

**2.4. Принцип разделения интерфейса (ISP):**
- Разделите интерфейс `AbstractEmployee` на специализированные:
  ```python
  class ISalaryCalculable(ABC):
      @abstractmethod
      def calculate_salary(self) -> float: pass

  class IInfoProvidable(ABC):
      @abstractmethod
      def get_info(self) -> str: pass

  class ISkillManageable(ABC):
      @abstractmethod
      def add_skill(self, skill: str): pass
  ```

**2.5. Принцип инверсии зависимостей (DIP):**
- Внедрите dependency injection для сервисов:
  - Создайте интерфейс `IEmployeeRepository`
  - Реализуйте `DatabaseEmployeeRepository` и `InMemoryEmployeeRepository`
  - Используйте внедрение через конструктор

#### **Часть 3: Устранение дублирования и упрощение кода**

1. **Применение DRY:**
   - Вынесите повторяющуюся логику валидации в отдельные классы
   - Создайте утилитные функции для общих операций
   - Устраните дублирование в методах расчета зарплат

2. **Применение KISS:**
   - Упростите сложные методы путем декомпозиции
   - Уберите избыточные проверки и условия
   - Упростите цепочки вызовов методов

3. **Применение YAGNI:**
   - Удалите неиспользуемый код и избыточные абстракции
   - Упростите интерфейсы, оставив только необходимые методы

#### **Часть 4: Рефакторинг конкретных проблем**

**4.1. Рефакторинг "длинного метода":**
- Разбейте метод `get_info()` на более мелкие специализированные методы
- Примените технику "извлечения метода"

**4.2. Рефакторинг "большого класса":**
- Разделите класс `Company` на:
  - `DepartmentManager`
  - `ProjectManager`
  - `FinancialCalculator`

**4.3. Улучшение именования:**
- Переименуйте переменные и методы в соответствии с их назначением
- Приведите именование к единому стандарту PEP8

#### **Часть 5: Внедрение инструментов качества**

1. **Настройка линтеров:**
   - Создайте конфигурационные файлы для `pylint` и `black`
   - Настройте автоматическое форматирование при коммите

2. **Создание pre-commit хуков:**
   - Настройте автоматический запуск тестов и линтеров
   - Добавьте проверку типов в процесс CI/CD

3. **Метрики качества:**
   - Измерьте метрики до и после рефакторинга:
     - Cyclomatic complexity
     - Lines of code
     - Code coverage

#### **Часть 6: Демонстрация результатов**

**6.1. Сравнительный анализ:**
```python
# ДО рефакторинга
class Employee:
    def calculate_salary(self):
        # Сложный метод со множеством условий
        if self.type == "manager":
            return self.base_salary + self.bonus
        elif self.type == "developer":
            if self.level == "junior":
                return self.base_salary * 1.0
            elif self.level == "middle":
                return self.base_salary * 1.5
            # ... и так далее

# ПОСЛЕ рефакторинга
class Employee:
    def __init__(self, salary_strategy: SalaryStrategy):
        self.salary_strategy = salary_strategy
    
    def calculate_salary(self):
        return self.salary_strategy.calculate(self)
```

**6.2. Демонстрация улучшений:**
- Покажите работу обновленной системы
- Продемонстрируйте легкость добавления нового типа сотрудника
- Покажите работу dependency injection

### **Требования к отчету:**

1. **Аналитическая часть:**
   - Отчет о первоначальном состоянии кода
   - Список выявленных проблем и "запахов кода"
   - Обоснование выбранных подходов к рефакторингу

2. **Практическая часть:**
   - Исходный код до рефакторинга (ветка в Git)
   - Исходный код после рефакторинга
   - Тесты, подтверждающие сохранение функциональности

3. **Метрики:**
   - Результаты статического анализа до/после
   - Покрытие тестами
   - Сравнение сложности кода

### **Критерии оценки:**

- **Удовлетворительно:** Проведен базовый рефакторинг 2-3 классов с применением 2+ принципов SOLID
- **Хорошо:** Рефакторинг охватывает основные модули системы, применены 4+ принципа SOLID, устранены ключевые "запахи кода"
- **Отлично:** Полный рефакторинг системы с применением всех принципов SOLID, внедрены инструменты качества, продемонстрировано значительное улучшение метрик

---

**Рекомендуемая литература:**
1. Роберт Мартин. «Чистый код. Создание, анализ и рефакторинг»
2. Мартин Фаулер. «Рефакторинг. Улучшение существующего кода»
3. Роберт Мартин. «Чистая архитектура»