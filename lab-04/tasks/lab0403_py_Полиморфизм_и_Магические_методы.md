### **Часть 3: Полиморфизм и Магические методы**

**Цель:** Реализовать полиморфное поведение объектов различных классов сотрудников. Освоить перегрузку операторов и использование магических методов в Python для создания более интуитивного и удобного интерфейса работы с объектами.

**Задание:**

**3.1. Углубленный полиморфизм в коллекциях**
1.  Создайте класс `Department` (Отдел).
2.  Реализуйте в нем следующие методы:
    *   `__init__(self, name: str)`: конструктор, инициализирует название отдела и пустой список сотрудников.
    *   `add_employee(self, employee: AbstractEmployee) -> None`: добавляет сотрудника в отдел.
    *   `remove_employee(self, employee_id: int) -> None`: удаляет сотрудника по ID.
    *   `get_employees(self) -> list[AbstractEmployee]`: возвращает список всех сотрудников.
    *   `calculate_total_salary(self) -> float`: вычисляет общую зарплату всех сотрудников отдела (демонстрирует полиморфизм - метод работает с разными типами сотрудников).
    *   `get_employee_count(self) -> dict[str, int]`: возвращает словарь с количеством сотрудников каждого типа (Manager, Developer, etc.). Для этого используйте функцию `isinstance()` или поле `__class__.__name__`.
    *   `find_employee_by_id(self, employee_id: int) -> Optional[AbstractEmployee]`: находит сотрудника по ID.

**3.2. Перегрузка операторов (магические методы)**
Для классов сотрудников реализуйте следующие магические методы:
*   `__eq__(self, other) -> bool`: сравнение сотрудников по `id`.
*   `__lt__(self, other) -> bool`: сравнение сотрудников по итоговой зарплате (для сортировки).
*   `__add__(self, other) -> float`: сложение двух сотрудников возвращает сумму их зарплат.
*   `__radd__(self, other) -> float`: поддержка суммирования в списке через `sum()` (например, `total = sum(employees_list)`).
*   Для класса `Department` реализуйте:
    *   `__len__(self) -> int`: возвращает количество сотрудников в отделе.
    *   `__getitem__(self, key) -> AbstractEmployee`: доступ к сотруднику по индексу (например, `dept[0]`).
    *   `__contains__(self, employee: AbstractEmployee) -> bool`: проверка принадлежности сотрудника отделу.

**3.3. Итерация по объектам**
1.  Реализуйте для класса `Department` метод `__iter__`, чтобы сделать его итерируемым (можно возвращать итератор списка сотрудников).
2.  Реализуйте для класса `Developer` метод `__iter__`, который будет позволять итерироваться по его стеку технологий (например, `for skill in developer:`).

**3.4. Сериализация и десериализация**
1.  Реализуйте для всех классов сотрудников метод `to_dict(self) -> dict`, который возвращает словарь с данными сотрудника.
2.  Реализуйте метод класса `from_dict(cls, data: dict) -> AbstractEmployee` для создания объекта из словаря.
3.  Реализуйте для класса `Department` методы:
    *   `save_to_file(self, filename: str) -> None`: сохраняет всех сотрудников отдела в JSON файл.
    *   `load_from_file(cls, filename: str) -> 'Department'`: загружает отдел из JSON файла.

**3.5. Компараторы и сортировка**
1.  Создайте несколько функций-компараторов для сортировки сотрудников:
    *   По имени
    *   По зарплате
    *   По отделу и затем по имени
2.  Продемонстрируйте сортировку списка сотрудников с использованием:
    *   `sorted()` с ключом (`key=`))
    *   `sorted()` с компаратором (`cmp=` в Python 3.2+ через `functools.cmp_to_key`)

**3.6. Тестирование и демонстрация**
В основной программе продемонстрируйте:
1.  Создание отдела и добавление в него сотрудников разных типов.
2.  Вызов `calculate_total_salary()` для отдела.
3.  Использование перегруженных операторов:
    *   Сравнение двух сотрудников (`==`, `<`)
    *   Суммирование зарплат сотрудников (`employee1 + employee2`)
    *   Суммирование списка сотрудников через `sum()`
    *   Проверка вхождения сотрудника в отдел (`in`)
    *   Доступ к сотрудникам отдела по индексу
4.  Итерацию по отделу и по стеку технологий разработчика.
5.  Сохранение и загрузку отдела из файла.
6.  Сортировку сотрудников по различным критериям.
7.  Поиск сотрудника по ID.

**Требования к коду:**
*   Все магические методы должны быть реализованы корректно
*   Обрабатывать крайние случаи (пустые значения, неверные типы)
*   Использовать полиморфизм везде, где это возможно
*   Код должен быть хорошо документирован

**Критерии оценки части 3:**
*   **Удовлетворительно:** Реализованы основные магические методы и полиморфное поведение в коллекциях
*   **Хорошо:** Полностью реализована перегрузка операторов, итерация и сериализация
*   **Отлично:** Реализованы все методы, включая компараторы для сортировки, обработку крайних случаев и полноценную демонстрацию работы. Составлена UML-диаграмма классов https://plantuml.com/ru/