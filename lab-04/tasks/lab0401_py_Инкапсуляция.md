### **Лабораторная работа 4: Реализация принципов ООП на примере системы учета сотрудников**

**Цель работы:** Освоить базовые принципы объектно-ориентированного программирования (ООП) на языке Python. Получить практические навыки создания иерархии классов, применения принципов инкапсуляции, наследования, полиморфизма и композиции для моделирования предметной области.

**Стек технологий:**
*   **Язык программирования:** Python 3.x
*   **Инструменты:** Любая IDE (PyCharm, VSCode и т.д.), Git для контроля версий (если работа ведется в рамках общего проекта).

**Теоретическая часть (краткое содержание из лекции):**
Объектно-ориентированное программирование — это парадигма, использующая объекты, содержащие данные и методы для их обработки. Ключевыми принципами ООП являются:
*   **Инкапсуляция:** Сокрытие внутренней реализации объекта и предоставление строго определенного интерфейса для взаимодействия с ним.
*   **Наследование:** Создание нового класса (потомка) на основе существующего (родителя), что позволяет повторно использовать код и выстраивать иерархии.
*   **Полиморфизм:** Возможность объектов с одинаковой спецификацией (интерфейсом) иметь различную реализацию.
*   **Композиция:** Построение сложных объектов из более простых, где один класс включает в себя объекты других классов.

**Предметная область:** Система учета сотрудников компании.

---

### **Задание на практическую реализацию:**

Работа разбита на 4 логически связанные части. Рекомендуется выполнять их последовательно, постепенно расширяя и модифицируя код.

#### **Часть 1: Инкапсуляция**

**Цель:** Реализовать базовый класс `Employee` (Сотрудник), инкапсулирующий данные о сотруднике.

**Задание:**
1.  Создайте класс `Employee`.
2.  В конструкторе класса (`__init__`) определите следующие **приватные (`private`)** атрибуты:
    *   `__id` (уникальный идентификатор сотрудника, целое число)
    *   `__name` (имя сотрудника, строка)
    *   `__department` (отдел, строка)
    *   `__base_salary` (базовая зарплата, вещественное число)
3.  Для каждого из этих атрибутов реализуйте **методы доступа (геттеры и сеттеры)**, используя декоратор `@property` и `@<attribute_name>.setter`.
    *   Геттер возвращает значение атрибута.
    *   Сеттер устанавливает значение атрибута, проводя базовые проверки (например, `id` и `base_salary` должны быть положительными числами, `name` не должно быть пустой строкой). В случае невалидных данных необходимо возбуждать исключение `ValueError` с описанием ошибки.
4.  Реализуйте метод `__str__` для возврата строкового представления объекта в формате: `"Сотрудник [id: {id}, имя: {name}, отдел: {department}, базовая зарплата: {base_salary}]"`.
5.  **Проверка:** В основной программе (`if __name__ == "__main__":`) создайте несколько объектов класса `Employee`. Продемонстрируйте:
    *   Корректную установку и получение значений через свойства.
    *   Попытку установки невалидных значений (должно вызывать исключение).
    *   Вывод объектов на экран.

**Критерии оценки части 1:**
*   Создан класс с приватными атрибутами.
*   Корректно реализованы свойства для доступа к атрибутам с валидацией.
*   Продемонстрирована работа с объектами, включая обработку ошибок.
*   Составлена UML-диаграмма классов https://plantuml.com/ru/

---

*(Последующие части — Наследование, Полиморфизм, Композиция — будут представлены в следующих заданиях и логически продолжат развитие этой же кодобазы.)*