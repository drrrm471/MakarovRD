### **Часть 2: Наследование и Абстракция**

**Цель:** Расширить систему учета сотрудников, создав иерархию классов на основе наследования. Ввести абстрактные классы для определения общего интерфейса.

**Задание:**

**2.1. Создание абстрактного базового класса**
1.  Создайте **абстрактный класс** `AbstractEmployee`, который наследуется от `ABC` (Abstract Base Class) из модуля `abc`.
2.  Перенесите в него общие атрибуты и методы из класса `Employee` (теперь он станет потомком этого класса). В `AbstractEmployee` объявите следующие **абстрактные методы** с помощью декоратора `@abstractmethod`:
    *   `def calculate_salary(self) -> float:` - для расчета итоговой заработной платы. Реализация будет разной для разных типов сотрудников.
    *   `def get_info(self) -> str:` - для получения полной информации о сотруднике.
3.  Сделайте класс `Employee` из Части 1 наследником `AbstractEmployee`. Реализуйте в нем эти абстрактные методы:
    *   `calculate_salary`: для обычного сотрудника итоговая зарплата равна базовой.
    *   `get_info`: должен возвращать строку, включающую всю информацию из `__str__`, а также рассчитанную зарплату.

**2.2. Создание иерархии классов сотрудников**
Создайте три новых класса, наследующихся от `Employee`:
*   `Manager` (Менеджер)
*   `Developer` (Разработчик)
*   `Salesperson` (Продавец)

Каждый класс должен иметь **дополнительные приватные атрибуты** и **переопределять** метод `calculate_salary` по своему.

*   **Для `Manager`:**
    *   Доп. атрибут: `__bonus` (бонус, вещественное число).
    *   Реализация `calculate_salary`: `базовая_зарплата + бонус`.
    *   Переопределите также метод `get_info`, чтобы он включал информацию о бонусе.

*   **Для `Developer`:**
    *   Доп. атрибуты: `__tech_stack` (список технологий, которыми владеет разработчик, list[str]), `__seniority_level` (уровень Seniority, строка, например, "junior", "middle", "senior").
    *   Реализация `calculate_salary`: Базовая зарплата умножается на коэффициент уровня:
        *   "junior": x1.0
        *   "middle": x1.5
        *   "senior": x2.0
    *   Реализуйте метод `add_skill(self, new_skill: str) -> None` для добавления новой технологии в стек.
    *   Переопределите `get_info`, чтобы он включал уровень и стек технологий.

*   **Для `Salesperson`:**
    *   Доп. атрибуты: `__commission_rate` (процент комиссии, вещественное число, например, 0.1 для 10%), `__sales_volume` (объем продаж, вещественное число).
    *   Реализация `calculate_salary`: `базовая_зарплата + (объем_продаж * процент_комиссии)`.
    *   Реализуйте метод `update_sales(self, new_sales: float) -> None`, который добавляет сумму к текущему объему продаж.
    *   Переопределите `get_info`, чтобы он включал процент комиссии и объем продаж.

**2.3. Фабричный метод (Дополнительная сложность)**
1.  Создайте класс `EmployeeFactory`.
2.  Реализуйте в нем статический метод `create_employee(emp_type: str, **kwargs) -> AbstractEmployee`.
3.  Метод должен на основе строкового параметра `emp_type` ("manager", "developer", "salesperson", "employee") и переданных именованных аргументов создавать и возвращать соответствующий объект сотрудника.
4.  Продемонстрируйте работу фабрики, создавая разные типы сотрудников.

**2.4. Тестирование и демонстрация**
В основной программе создайте и продемонстрируйте:
1.  По одному экземпляру каждого типа сотрудника (`Manager`, `Developer`, `Salesperson`, `Employee`).
2.  Для каждого экземпляра:
    *   Установите значения атрибутов (в т.ч. через сеттеры).
    *   Вызовите метод `calculate_salary()` и выведите результат.
    *   Вызовите метод `get_info()` и выведите результат.
3.  Продемонстрируйте работу фабричного метода, создав с его помощью несколько сотрудников.
4.  Создайте список (`list`) или словарь (`dict`) с объектами разных типов и итерируйтесь по нему, выводя для каждого информацию через `get_info()`, демонстрируя полиморфное поведение (которое будет полностью реализовано в Части 3).

**Требования к коду:**
*   Все новые атрибуты должны быть приватными и иметь соответствующие свойства.
*   Использовать `super()` для вызова методов родительского класса в конструкторах.
*   Код должен быть документирован (docstrings для классов и методов).
*   Для проверок в сеттерах использовать утверждения `assert` или возбуждать исключения `ValueError`.

**Критерии оценки части 2:**
*   **Удовлетворительно:** Реализованы и работают классы `Manager`, `Developer`, `Salesperson` с корректным наследованием и переопределением метода `calculate_salary`.
*   **Хорошо:** Реализован абстрактный базовый класс `AbstractEmployee`. Все классы реализуют абстрактные методы. Продемонстрирована работа системы.
*   **Отлично:** Реализован класс `EmployeeFactory` с фабричным методом. Код хорошо структурирован, задокументирован и использует `super()`. Продемонстрирована работа с коллекцией объектов. Составлена UML-диаграмма классов https://plantuml.com/ru/